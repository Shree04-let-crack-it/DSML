# -*- coding: utf-8 -*-
"""crop .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fuyFpPJmYoesGPzyPrJJa1-6V-JkxILN
"""

!pip install ipywidgets
import pandas as pd
import numpy as np
from scipy import stats

import ipywidgets as widgets
from IPython.display import display

import seaborn as sns
import matplotlib.pyplot as plt
from plotly.subplots import make_subplots

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, KFold, GridSearchCV
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_squared_log_error
from sklearn.preprocessing import OrdinalEncoder
from sklearn import preprocessing
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix
import missingno as msno
import warnings
warnings.filterwarnings('ignore')
import plotly
import plotly.graph_objs as go
import plotly.express as px
from plotly.subplots import make_subplots
from plotly.offline import iplot, init_notebook_mode
from sklearn.model_selection import train_test_split, KFold, GridSearchCV


from sklearn.metrics import accuracy_score

from sklearn.neighbors import KNeighborsRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split, KFold, GridSearchCV
from sklearn.linear_model import LinearRegression, ElasticNet,Ridge
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_squared_log_error
import xgboost as xgb
from sklearn.ensemble import RandomForestRegressor

df=pd.read_csv('/content/Crop_production.csv')

df.head()
df.info()

df.isna()/len(df)*100



df.dropna(inplace=True)

df.isnull()

print(df[df['Crop'] == 'Cotton'])

df.info()

df.describe()

df.info()

from sklearn.preprocessing import OrdinalEncoder

# Create an instance of the OrdinalEncoder
encoder = OrdinalEncoder()

# Fit the encoder to the 'Crop' column and transform it
df['Crop_Type_encoded'] = encoder.fit_transform(df[['Crop_Type']])
df['State_Name_encoded'] = encoder.fit_transform(df[['State_Name']])

# Display the DataFrame with the encoded column
df.head()

# Drop columns and assign the result back to df (or a new variable)
df = df.drop('Unnamed: 0', axis=1) # Specify axis=1 for columns explicitly
df = df.drop('State_Name', axis=1)
df = df.drop('Crop_Type', axis=1)
df = df.drop('Crop', axis=1)

# Now df has the dropped columns, and you can assign it to df1 if needed
df1 = df.copy() # Create a copy if you need a separate df1

df1.info()

plt.figure(figsize=(15, 10))
df.hist()
plt.show()

plt.figure(figsize=(15, 8))
df.boxplot()
plt.xticks(rotation=45)
plt.show()

df.boxplot(column=['temperature'])
plt.show()



plt.scatter(df['Production_in_tons'], df['Area_in_hectares'])
plt.xlabel('Production_in_tons')
plt.ylabel('Area_in_hectares')
plt.show()

import seaborn as sns
sns.pairplot(df)
plt.show()

df.describe()

df.corr()

import matplotlib.pyplot as plt

df.corr()
plt.show()

import seaborn as sns

sns.heatmap(df.corr())

# heatmap

sns.heatmap(df.corr(), annot=True, cmap="viridis", linewidths=.5)
plt.title("Correlation Matrix")
plt.show()

mask = (df.corr() > 0.7)


filtered_correlation_matrix = df.corr().where(mask)


sns.heatmap(filtered_correlation_matrix, annot=True, cmap="plasma", linewidths=.5)
plt.title("Correlation Matrix (>|0.7|)")
plt.show()
df.info()

df.info()

columns_to_convert = ['N', 'P', 'K']
for col in columns_to_convert:
    if col in df.columns and df[col].dtype == np.int64:
        df[col] = df[col].astype(np.int32)

columns_to_convert = ['pH', 'rainfall', 'temperature', 'Production_in_tons', 'Yield_ton_per_hec','Area_in_hectares']
for col in columns_to_convert:
    if col in df.columns and df[col].dtype == np.float64:
        df[col] = df[col].astype(np.int32)

df.info()

columns_to_convert = ['Crop_encoded','Crop_Type_encoded','State_Name_encoded']
for col in columns_to_convert:
    if col in df.columns and df[col].dtype == np.float64:
        df[col] = df[col].astype(np.int32)

X = df.drop('Yield_ton_per_hec', axis=1)  # Features
y = df['Yield_ton_per_hec']  # Target variable

from sklearn.model_selection import train_test_split

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Print the shapes of the resulting sets
print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

y_train = y_train.replace([np.inf, -np.inf], np.nan)

# Option 1: Remove rows with NaN values
# X_train = X_train[y_train.notna()]
# y_train = y_train[y_train.notna()]

# Option 2: Impute NaN values with the mean or median
y_train = y_train.fillna(y_train.mean())  # Or use y_train.median()

models = [RandomForestRegressor(), LinearRegression(), ElasticNet(), KNeighborsRegressor(), xgb.XGBRegressor(), Ridge()]
scores = dict()

for model in models:  # Changed 'models' to 'model' in the loop
    # Replace infinite or overly large values in X_train with NaN
    X_train = X_train.replace([np.inf, -np.inf], np.nan)
    # Impute NaN values with the mean
    X_train = X_train.fillna(X_train.mean())

    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    print(y_pred)

    print(f'model: {str(model)}')
    print(f'RMSE: {mean_squared_error(y_test, y_pred)}')
    print(f'MAE: {mean_absolute_error(y_test, y_pred)}')
    print('-' * 30, '\n')

# ... your existing code ...

model = xgb.XGBRegressor()  # Initialize the XGBoost model
model.fit(X_train, y_train)  # Fit the model with your training data

# Predict on the test data to avoid implicit display of the model
y_pred = model.predict(X_test)

# ... (rest of your code where you actually use y_pred)...

# ... your existing code ...

# Import XGBoost
import xgboost as xgb

model = xgb.XGBRegressor()  # Initialize the XGBoost model
model.fit(X_train, y_train)  # Fit the model with your training data

# Predict on the test data to avoid implicit display of the model
y_pred = model.predict(X_test)

# ... (rest of your code where you actually use y_pred)...

!pip install scikit-learn==1.3.1

# Define input widgets for each feature
N_input = widgets.IntText(description="N:")
P_input = widgets.IntText(description="P:")
K_input = widgets.IntText(description="K:")
temperature_input = widgets.FloatText(description="Temperature:")
pH_input = widgets.FloatText(description="pH:")
area_input = widgets.IntText(description="Area (hectares):")
rainfall_input = widgets.FloatText(description="Rainfall:")
production_input = widgets.FloatText(description="Production (tons):")

# Add widgets for the encoded categorical features (using LabelEncoder output)
state_name_encoded_label_input = widgets.IntText(description="State Name Encoded (Label):")
crop_type_encoded_label_input = widgets.IntText(description="Crop Type Encoded (Label):")
crop_encoded_label_input = widgets.IntText(description="Crop Encoded (Label):")


# Function to handle prediction when button is clicked
def predict_on_input(b):
    input_data = pd.DataFrame({
        'N': [N_input.value],
        'P': [P_input.value],
        'K': [K_input.value],
        'temperature': [temperature_input.value],
        'pH': [pH_input.value],
        'Area_in_hectares': [area_input.value],
        'rainfall': [rainfall_input.value],
        'Production_in_tons': [production_input.value],
        # Include the new LabelEncoded categorical features
        'State_Name_encoded_label': [state_name_encoded_label_input.value],
        'Crop_Type_encoded_label': [crop_type_encoded_label_input.value],
        'Crop_encoded_label': [crop_encoded_label_input.value]
    })

    # Ensure the order of columns matches the training data (X_train)
    # It's crucial that this list exactly matches the columns used to train your model
    # You can get the correct column order from X_train.columns after dropping
    # the original categorical columns and adding the new encoded ones.
    # For demonstration, assuming these are the columns:
    expected_columns = ['N', 'P', 'K', 'pH', 'rainfall', 'temperature', 'Area_in_hectares', 'Production_in_tons',
                        'State_Name_encoded_label', 'Crop_Type_encoded_label', 'Crop_encoded_label']
    input_data = input_data[expected_columns]


    predictions = model.predict(input_data)
    print("Predicted Value:", predictions[0])


# Create a button to trigger prediction
predict_button = widgets.Button(description="Predict")
predict_button.on_click(predict_on_input)

# Display the input widgets and button, including the new widgets
display(N_input, P_input, K_input, temperature_input, pH_input, area_input, rainfall_input, production_input,
        state_name_encoded_label_input, crop_type_encoded_label_input, crop_encoded_label_input, predict_button)

y_pred = model.predict(X_test)